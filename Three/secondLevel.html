<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>My first three.js app</title>
		<style>
			body { margin: 0; }

		</style>
	</head>
	<body>

		<script src="js/three.js"></script>

		<script src="js/OrbitControls.js"></script>
		<script src="js/physi.js"></script>
		<script src="js/GLTFLoader.js"></script>
		<script src="js/perlin_noise.js"></script>
		<script src="js/ammo.js"></script>
		<script src="js/THREEBSP.js"></script>

		<script>

				Physijs.scripts.worker='js/physijs_worker.js';

				//THREE types of material : MeshBasicMaterial,MeshPhongMaterial,MeshLambertMaterial.The second two require a light source.

				//set variables for our entirer game
				let scene,camera,friction,damping,renderer,spotLight,ambiLight,scoreText,infoText,timer,moon,ballObject,cubeMat,canvas,graphics;
				//group for our orbiting planets
				let group=new THREE.Group();
				//next 5 lines is what we need for our rocket model to convert to physics
				let rocketBuffer=new THREE.BufferGeometry();
				let rocketThings=[];
				let rocketMeshes=[];
				let rocketObject;
				let r=new THREE.Geometry();
				//next 5 lines is what we need for our astronaut model to convert to physics
				let astronautBuffer=new THREE.BufferGeometry();
				let astronautThings=[];
				let astronautMeshes=[];
				let astronautObject;
				let a=new THREE.Geometry();
				//list of our models
        const models = {
				  moon:    { url: 'models/neptune/scene.gltf' },
				  rocket:    { url: 'models/rocket/scene.gltf' },
					astronaut:    { url: 'models/antena/scene.gltf' },
				};
				//object array to hold our models in a structure for easy accessing
				let objects=[];
				//array of enemies
				let Enemies=[];
				//loading manager which is important for models
				const manager=new THREE.LoadingManager();
				//calls the init function when we done loading model/s
				manager.onLoad=init;

				//loads our models by looping through object models ( a few lines up)
				const gltfLoader=new THREE.GLTFLoader(manager);
				for (const model of Object.values(models)) {
					gltfLoader.load(model.url, (gltf) => {
						objects.push(gltf.scene);
					});
				}


				//setup function
				function init(){
					console.log(objects.length);
					//gets the first model from objects array and makes it moon
					moon=objects[0];
					//transformations to moon
					moon.position.y=170;
					moon.position.x=250;
					moon.position.z=450;
					moon.scale.set(15,15,15);
					//adds to the group not the scene as we'll add the entire group to the scene at the end
					group.add(moon);
				//adds the score to the document
				scoreText = document.createElement('div');
				scoreText.style.position = 'absolute';
				scoreText.style.width = 100;
				scoreText.style.height = 100;
				scoreText.style.color="white";
				scoreText.innerHTML = "0";
				scoreText.style.top = 80 + 'px';
				scoreText.style.left = 100 + 'px';
				document.body.appendChild(scoreText);

				//creates a canvas element that represents our map
				canvas=document.createElement("CANVAS");
				graphics=canvas.getContext("2d");
				canvas.style.position="absolute";
				canvas.style.background="white";
				canvas.style.border="4px solid white";
				canvas.width = 900;
				canvas.height = 900;
				canvas.style.top = 480 + 'px';
				canvas.style.left = 100 + 'px';
				document.body.appendChild(canvas);

				//adds info text to the document
				infoText = document.createElement('div');
				infoText.style.position = 'absolute';
				infoText.style.width = 100;
				infoText.style.height = 100;
				infoText.style.color="white";
				infoText.innerHTML = "Use arrow keys to move and space bar to stop UFO. Destroy the asteroids bud.";
				infoText.style.top = 60 + 'px';
				infoText.style.left = 100 + 'px';
				document.body.appendChild(infoText);

				//adds timer to the document
				timer=document.createElement('div');
				timer.style.position='absolute';
				timer.style.width=100;
				timer.style.height=100;
				timer.style.color='white';
				timer.innerHTML="0";
				timer.style.top=33+'px';
				timer.style.left=100+'px';
				document.body.appendChild(timer);

				alert("DESTROY THE ASTEROIDS BEFORE ITS TOO LATE")
				damping=0.7;
				friction=0.9;//high
				scene=new Physijs.Scene; //Scene physics

				scene.setGravity(new THREE.Vector3(0,-20,0));//gravity for scene

				//loads the sky material
				var loader=new THREE.TextureLoader();
				var mat=loader.load('textures/sky.jpg');
				//creates massive cube which acts as a background(skybox)
				cubeMat=new THREE.MeshBasicMaterial({map:mat,side:THREE.DoubleSide});
				var cube=new THREE.Mesh(new THREE.BoxGeometry(1700,1700,1700),cubeMat);
				scene.add(cube);
				//scene.background=mat;

				//creates camera and positions it
				camera=new THREE.PerspectiveCamera(40,window.innerWidth/window.innerHeight,0.1,1000);
				camera.rotation.y=-Math.PI/2;
				camera.position.x=-120;
				camera.position.y=50;

				//what must the camera look at
				camera.lookAt(scene.position);




				//renderer that renders our actual screen
				renderer=new THREE.WebGLRenderer({antialias:true});
				renderer.setSize(window.innerWidth,window.innerHeight);
				document.body.appendChild(renderer.domElement);
				//resize screen based on window size
				window.addEventListener('resize',()=>{
					renderer.setSize( window.innerWidth, window.innerHeight );
				 	camera.aspect=window.innerWidth / window.innerHeight;
				 	camera.updateProjectionMatrix();
				});

				//second parameter of lights is the intensity, first is the color

				//creates SpotLight for wall infront of car
				var spotLight=new THREE.DirectionalLight(0xffffff,0.5);
				spotLight.position.set(-420,20,0);//spotLight doesnt need target
				scene.add(spotLight);

				//creates SpotLight for wall infront of car
				var spotLight=new THREE.DirectionalLight(0xffffff,0.5);
				spotLight.position.set(420,20,0);//spotLight doesnt need target
				scene.add(spotLight);

				//creates SpotLight for wall infront of car
				var spotLight=new THREE.DirectionalLight(0xffffff,0.5);
				spotLight.position.set(0,20,-420);//spotLight doesnt need target
				scene.add(spotLight);

				var spotLight=new THREE.DirectionalLight(0xffffff,0.5);
				spotLight.position.set(0,20,420);//spotLight doesnt need target
				scene.add(spotLight);

				//creates DirectionalLight for the blue moon on top of the car, press ESC to see moon
				var directionalLight=new THREE.DirectionalLight(0xffffff,0.5);
				scene.add(directionalLight.target);//directionalLight must have a target
				directionalLight.position.set(270,170,50);
				directionalLight.target=moon;//respective target for directionalLight
				scene.add(directionalLight);




				//note that some walls are dim because no light shining on it

				//adds general light to screen
				var ambiLight=new THREE.AmbientLight(0xffffff,1);//if set to 1 then no other light is needed but then we cant have shadows
				//scene.add(ambiLight);
				requestAnimationFrame(animate);
			}

			//function to create all the boxes in the scene which represent enemies
			function boxes(){
				//create general box
				var cube=new THREE.CubeGeometry(45,45,45);
				//texture laoder for all our textures
				var loader=new THREE.TextureLoader();

				var mat=loader.load('textures/color1.jpg');
				var color1=new THREE.MeshLambertMaterial({map:mat});//sets box 1 to this texture

				var mat2=loader.load('textures/color2.jpg');
				var color2=new THREE.MeshLambertMaterial({map:mat2});

				var mat3=loader.load('textures/color3.jpg');
				var color3=new THREE.MeshLambertMaterial({map:mat3});

				var mat4=loader.load('textures/color4.jpg');
				var color4=new THREE.MeshLambertMaterial({map:mat4});

				//creates physics objects of the above boxes
				var mesh1=new Physijs.BoxMesh(cube,color1);
				var mesh2=new Physijs.BoxMesh(cube,color2);
				var mesh3=new Physijs.BoxMesh(cube,color3);
				var mesh4=new Physijs.BoxMesh(cube,color4);
				//positions box1
				mesh1.position.x=0;
				mesh1.position.z=-240;
				mesh1.position.y=30;
				//positions box2
				mesh2.position.x=360;
				mesh2.position.z=180;
				mesh2.position.y=30;
				//positions box3
				mesh3.position.x=0;
				mesh3.position.z=360;
				mesh3.position.y=30;
				//positions box4
				mesh4.position.x=-300;
				mesh4.position.z=-100;
				mesh4.position.y=30;
				//sets the velocities to zero to prevent movement of these enemies
				mesh1.setLinearVelocity(new THREE.Vector3(0,0,0));
				mesh1.setAngularVelocity(new THREE.Vector3(0,0,0));
				mesh2.setLinearVelocity(new THREE.Vector3(0,0,0));
				mesh2.setAngularVelocity(new THREE.Vector3(0,0,0));
				mesh3.setLinearVelocity(new THREE.Vector3(0,0,0));
				mesh3.setAngularVelocity(new THREE.Vector3(0,0,0));
				mesh4.setLinearVelocity(new THREE.Vector3(0,0,0));
				mesh4.setAngularVelocity(new THREE.Vector3(0,0,0));

				//adds enemies to enemies array for later use
				Enemies.push(mesh1);
				Enemies.push(mesh2);
				Enemies.push(mesh3);
				Enemies.push(mesh4);


				//adds all our boxes to the scene
				scene.add(mesh1);
				scene.add(mesh2);
				scene.add(mesh3);
				scene.add(mesh4);
			}

			//function to create physics model of rocket
			function addRocket(){
				//lines 270-288 are always needed when converting model to physics
				var rocket=objects[1];
				rocket.traverse(function(child){
					if(child.isMesh){
						rocketBuffer=child.geometry;

						rocketThings.push(rocketBuffer);
					}
				});
				for(var i=0;i<rocketThings.length;i++){
				  var loader=new THREE.TextureLoader();
				  var mat=loader.load('textures/gala.jpg');
				  var carmat=new THREE.MeshBasicMaterial({map:mat});
				  var mesh=new THREE.Mesh(rocketThings[i],carmat);
				  rocketMeshes.push(mesh);
				}
				var mats=[carmat];

				var rocketbody=new THREE.Geometry().fromBufferGeometry(rocketMeshes[0].geometry);
				r.merge(rocketbody,rocketMeshes[0].matrix);


				console.log(r);
				//creates physics model of rocket
				var rocketObj=new Physijs.BoxMesh(r,mats,0);

				//positions rocket in scene
				rocketObj.position.x=-100;
				rocketObj.position.z=100;
				rocketObj.position.y=1.6;
				rocketObj.rotation.x=-22;
				//scales rocket as this model was small , others would need to be scaled by a low factor as they are massive
				rocketObj.scale.set(4,4,4);
				//sets rocket to global variable rocketObject
				rocketObject=rocketObj;
				//on collision event listener for rocket
				rocketObject.addEventListener("collision",function(object){
					x=object.id;
					//prevents rocket from moving when collided with
					rocketObject.setAngularVelocity(new THREE.Vector3(0,0,0));
					rocketObject.setLinearVelocity(new THREE.Vector3(0,0,0));
					//checks if the collided object is the ufo and scale is a certain size
					if(x==ufo.id && ufo.scale.x<2.6){
						//resets car as its not big enough to destroy enemy
						console.log("nope");
						rocketObject.setAngularVelocity(new THREE.Vector3(0,0,0));
						rocketObject.setLinearVelocity(new THREE.Vector3(0,0,0));
						ufo.position.x=0;
						ufo.position.y=20;
						ufo.position.z=0;
						ufo.scale.set(2,2,2);
						ufo.setLinearVelocity(new THREE.Vector3(0, 0, 0));
						ufo.setAngularVelocity(new THREE.Vector3(0, 0, 0));
						ufo.__dirtyPosition=true;
						//sets score to 0
						score=0;
						scoreText.innerHTML=score.toString();
						clock.stop();
						alert("You have failed this planet");
						//restarts clock
						clock.start();
						console.log(rocketMeshes.length);
					}
					//performs if object colliding with enemy is ufo and size is big enough to destroy enemy
					else if(x==ufo.id && ufo.scale.x>=2.6){
						ufo.setLinearVelocity(new THREE.Vector3(0, 0, 0));
						ufo.setAngularVelocity(new THREE.Vector3(0, 0, 0));
						//rocketObject.position.z=-1000;
						//remove object if we too big
						scene.remove(rocketObject);
						console.log("hey");
					}
				});
				//push rocket to enemy array
				Enemies.push(rocketObject);
				scene.add(rocketObject);
			}
			//does exact thing as function above just with the satellite
			function addSatellite(){
				var astronaut=objects[2];
				astronaut.traverse(function(child){
					if(child.isMesh){
					astronautBuffer=child.geometry;

						astronautThings.push(astronautBuffer);
					}
				});
				for(var i=0;i<astronautThings.length;i++){
				  var loader=new THREE.TextureLoader();
				  var mat=loader.load('models/antena/textures/Material_baseColor.png');
				  var carmat=new THREE.MeshBasicMaterial({map:mat});
				  var mesh=new THREE.Mesh(astronautThings[i],carmat);
				  astronautMeshes.push(mesh);
				}
				var mats=[carmat];
				console.log(astronautMeshes.length);
				console.log("sup");
				var astronautbody=new THREE.Geometry().fromBufferGeometry(astronautMeshes[0].geometry);
				a.merge(astronautbody,astronautMeshes[0].matrix);


				console.log(a);
				var astronautObj=new Physijs.BoxMesh(a,mats,0);

				astronautObj.position.x=250;
				astronautObj.position.z=-150;
				astronautObj.position.y=-23;
			  astronautObj.rotation.x=25;
				astronautObj.scale.set(2,2,2);
				astronautObject=astronautObj;
				astronautObject.addEventListener("collision",function(object){
					x=object.id;
					astronautObject.setAngularVelocity(new THREE.Vector3(0,0,0));
					astronautObject.setLinearVelocity(new THREE.Vector3(0,0,0));
					if(x==ufo.id && ufo.scale.x<2.6){
						console.log("nope");
						astronautObject.setAngularVelocity(new THREE.Vector3(0,0,0));
						astronautObject.setLinearVelocity(new THREE.Vector3(0,0,0));
						ufo.position.x=0;
						ufo.position.y=20;
						ufo.position.z=0;
						ufo.scale.set(2,2,2);
						ufo.setLinearVelocity(new THREE.Vector3(0, 0, 0));
						ufo.setAngularVelocity(new THREE.Vector3(0, 0, 0));
						ufo.__dirtyPosition=true;
						score=0;
						scoreText.innerHTML=score.toString();
						clock.stop();
						alert("You have failed this planet");
						clock.start();
						console.log(rocketMeshes.length);
					}
					else if(x==ufo.id && ufo.scale.x>=2.6){
						ufo.setLinearVelocity(new THREE.Vector3(0, 0, 0));
						ufo.setAngularVelocity(new THREE.Vector3(0, 0, 0));
						//rocketObject.position.z=-1000;
						scene.remove(astronautObject);
						console.log("hey");
					}
				});
				Enemies.push(astronautObject);
				scene.add(astronautObject);
			}


				//creates Land that we drive on
				function createLand(){
					var ground_material, ground_geometry,sun, ground;

					var loader=new THREE.TextureLoader();
					var mat=loader.load('textures/sky.jpg');
					ground_material = Physijs.createMaterial(
						new THREE.MeshBasicMaterial( { color: 0xfffff ,opacity:0,transparent:true} ),friction, .9 // low restitution,transparent ground
					);
					// Ground
					ground = new Physijs.BoxMesh(new THREE.BoxGeometry(900, 1, 900),ground_material,0 // mass
					);

					scene.add( ground );
					//walls
					var text=new THREE.TextureLoader();
					var mat=text.load("textures/neon.jpg")
					var wall_material =
						new THREE.MeshLambertMaterial( { color: 0xfe019a } ) ;// low restitution;
					var wallHeight=30;
					var wallLength=900;
					var wall1 = new Physijs.BoxMesh(new THREE.BoxGeometry(wallLength, wallHeight, 15),wall_material,0 // mass
					);

					//collision events
					wall1.addEventListener('collision',()=>{
						//position for ufo)
						ufo.position.x=0;
						ufo.position.y=20;
						ufo.position.z=0;
						ufo.scale.set(2,2,2);
						//sets velocity of ufo to zero so that it doesnt move after the accident
						ufo.setLinearVelocity(new THREE.Vector3(0, 0, 0));
						ufo.setAngularVelocity(new THREE.Vector3(0, 0, 0));
						//always put this when changing position of objects in the scene
						ufo.__dirtyPosition=true;
						//reset score
						score=0;
						scoreText.innerHTML=score.toString();
						//stop timer
						clock.stop();
						alert("You have failed this planet");
						//restart timer
						clock.start();
					});

					wall1.position.y=wallHeight/2;
					wall1.position.z=wallLength/2;
					scene.add( wall1 );
					var wall2 = new Physijs.BoxMesh(new THREE.BoxGeometry(wallLength, wallHeight, 15),wall_material,0 // mass
					);

					//same as first collision example
					wall2.addEventListener('collision',()=>{
						ufo.position.x=0;
						ufo.position.y=20;
						ufo.position.z=0;
						ufo.scale.set(2,2,2);
						ufo.setLinearVelocity(new THREE.Vector3(0, 0, 0));
						ufo.setAngularVelocity(new THREE.Vector3(0, 0, 0));
						ufo.__dirtyPosition=true;
						score=0;
						scoreText.innerHTML=score.toString();
						clock.stop();
						alert("You have failed this planet");
						clock.start();
					});

					wall2.position.y=wallHeight/2;
					wall2.position.z=-wallLength/2;
					scene.add( wall2 );
					var wall3 = new Physijs.BoxMesh(new THREE.BoxGeometry(15, wallHeight, wallLength),wall_material,0 // mass
					);

					//same as first collision example
					wall3.addEventListener('collision',()=>{
						ufo.position.x=0;
						ufo.position.y=20;
						ufo.position.z=0;
						ufo.scale.set(2,2,2);
						ufo.setLinearVelocity(new THREE.Vector3(0, 0, 0));
						ufo.setAngularVelocity(new THREE.Vector3(0, 0, 0));
						ufo.__dirtyPosition=true;
						score=0;
						scoreText.innerHTML=score.toString();
						clock.stop();
						alert("You have failed this planet");
						clock.start();
					});

					wall3.position.y=wallHeight/2;
					wall3.position.x=-wallLength/2;
					scene.add( wall3 );
					var wall4 = new Physijs.BoxMesh(new THREE.BoxGeometry(15, wallHeight, wallLength),wall_material,0 // mass
					);

					//same as first collision example
					wall4.addEventListener('collision',()=>{
						ufo.position.x=0;
						ufo.position.y=20;
						ufo.position.z=0;
						ufo.scale.set(2,2,2);
						ufo.setLinearVelocity(new THREE.Vector3(0, 0, 0));
						ufo.setAngularVelocity(new THREE.Vector3(0, 0, 0));
						ufo.__dirtyPosition=true;
						score=0;
						scoreText.innerHTML=score.toString();
						clock.stop();
						alert("You have failed this planet");
						clock.start();
					});

					wall4.position.y=wallHeight/2;
					wall4.position.x=wallLength/2;
					scene.add( wall4 );


					}

					//function to create asteroid/planet
				function createBall(){
				//geometry is a sphere
				var ball=new THREE.SphereGeometry(10,32,32);
				//loads a texture
				var loader=new THREE.TextureLoader();
				var m=loader.load("textures/moon.jpeg");
				//sets material to map to loaded texture , if you want transparency put after 'm' transparent:true,same with opacity but opacity:0.5
				var ballmat=new THREE.MeshBasicMaterial({map:m});
				//physic objects always boxmesh for collision ease
				ballObject=new Physijs.BoxMesh(ball,ballmat);
				//produces value between 400 and 300
				var range=100*Math.random()+300;
				//sets ball position based on range
				ballObject.position.x = 250;
				ballObject.position.z = 50;
				ballObject.__dirtyPosition=true;
				ballObject.position.y=10.5;
				ballObject.setLinearVelocity(new THREE.Vector3(0, 0, 0));
				ballObject.setAngularVelocity(new THREE.Vector3(0, 0, 0));
				//not sure what this does but just keep it
				ballObject.setDamping(0,0.9);

				//ballObjectect.scale.set(5,5,5);//can scale if we want but then we'd have to change y position
				scene.add(ballObject);

				//ballObject event listener
				ballObject.addEventListener('collision',function(object){
				x=object.id;
				//check if collided object is the ufo
				if(x==ufo.id){
					//find a value from 300-400
				var range=100*Math.random()+300;
				ballObject.position.y=10.5;
				//checks current ball position
				if(ballObject.position.x>0 && ballObject.position.z>0){
					//random value from 0-2
				val=Math.floor(Math.random()*3);
				//20 lines of code below sets new position of planet depending on random number produced above
				if(val==0){
				ballObject.position.x = -range;
				ballObject.position.z = -range;
				ballObject.__dirtyPosition=true;
				ballObject.setLinearVelocity(new THREE.Vector3(0, 0, 0));
				ballObject.setAngularVelocity(new THREE.Vector3(0, 0, 0));
				}
				else if(val==1){
					ballObject.position.x = -range;
					ballObject.position.z = range;
					ballObject.__dirtyPosition=true;
					ballObject.setLinearVelocity(new THREE.Vector3(0, 0, 0));
					ballObject.setAngularVelocity(new THREE.Vector3(0, 0, 0));
				}
				else if(val==2){
					ballObject.position.x = range;
					ballObject.position.z = -range;
					ballObject.__dirtyPosition=true;
					ballObject.setLinearVelocity(new THREE.Vector3(0, 0, 0));
					ballObject.setAngularVelocity(new THREE.Vector3(0, 0, 0));
				}
				}
				//else if for first if
				else if(ballObject.position.x>0 && ballObject.position.z<0){
					val=Math.floor(Math.random()*3);
					if(val==0){
					ballObject.position.x = -range;
					ballObject.position.z = range;
					ballObject.__dirtyPosition=true;
					ballObject.setLinearVelocity(new THREE.Vector3(0, 0, 0));
					ballObject.setAngularVelocity(new THREE.Vector3(0, 0, 0));
					}
					else if(val==1){
						ballObject.position.x = -range;
						ballObject.position.z = -range;
						ballObject.__dirtyPosition=true;
						ballObject.setLinearVelocity(new THREE.Vector3(0, 0, 0));
						ballObject.setAngularVelocity(new THREE.Vector3(0, 0, 0));
					}
					else if(val==2){
						ballObject.position.x = range;
						ballObject.position.z = range;
						ballObject.__dirtyPosition=true;
						ballObject.setLinearVelocity(new THREE.Vector3(0, 0, 0));
						ballObject.setAngularVelocity(new THREE.Vector3(0, 0, 0));
					}
					}
				else if(ballObject.position.x<0 && ballObject.position.z>0){
					val=Math.floor(Math.random()*3);
					if(val==0){
					ballObject.position.x = range;
					ballObject.position.z = -range;
					ballObject.__dirtyPosition=true;
					ballObject.setLinearVelocity(new THREE.Vector3(0, 0, 0));
					ballObject.setAngularVelocity(new THREE.Vector3(0, 0, 0));
					}
					else if(val==1){
						ballObject.position.x = -range;
						ballObject.position.z = -range;
						ballObject.__dirtyPosition=true;
						ballObject.setLinearVelocity(new THREE.Vector3(0, 0, 0));
						ballObject.setAngularVelocity(new THREE.Vector3(0, 0, 0));
					}
					else if(val==2){
						ballObject.position.x = range;
						ballObject.position.z = range;
						ballObject.__dirtyPosition=true;
						ballObject.setLinearVelocity(new THREE.Vector3(0, 0, 0));
						ballObject.setAngularVelocity(new THREE.Vector3(0, 0, 0));
					}
					}
					//else if for first if
				else if(ballObject.position.x<0 && ballObject.position.z<0){
					val=Math.floor(Math.random()*3);
					if(val==0){
					ballObject.position.x = range;
					ballObject.position.z = range;
					ballObject.__dirtyPosition=true;
					ballObject.setLinearVelocity(new THREE.Vector3(0, 0, 0));
					ballObject.setAngularVelocity(new THREE.Vector3(0, 0, 0));
					}
					else if(val==1){
						ballObject.position.x = -range;
						ballObject.position.z = range;
						ballObject.__dirtyPosition=true;
						ballObject.setLinearVelocity(new THREE.Vector3(0, 0, 0));
						ballObject.setAngularVelocity(new THREE.Vector3(0, 0, 0));
					}
					else if(val==2){
						ballObject.position.x = range;
						ballObject.position.z = -range;
						ballObject.__dirtyPosition=true;
						ballObject.setLinearVelocity(new THREE.Vector3(0, 0, 0));
						ballObject.setAngularVelocity(new THREE.Vector3(0, 0, 0));
					}
					}
					//increments score variable if we bump into planet/asteroid
				score++;
				//converts to string to use in document
				scoreText.innerHTML=(score).toString();
				//sets ballObject to zero to prevent after collisions
				ballObject.setLinearVelocity(new THREE.Vector3(0, 0, 0));
				ballObject.setAngularVelocity(new THREE.Vector3(0, 0, 0));
			}
				});
				return ballObject;
		}


//function to create our UFO
function createUFO(){

		//first five lines creates bottom donut part of ufo
	var geometry = new THREE.TorusGeometry( 10, 2, 16, 100 );
	var material = new THREE.MeshBasicMaterial( { color: 0xffff00 } );
	var torus1 = new THREE.Mesh( geometry, material );
	torus1.rotation.x=29.8;
	torus1.position.y=-9;

	//next five lines creates second bottom donut part of ufo
	var geometry = new THREE.TorusGeometry( 7, 2, 16, 100 );
	//var material = new THREE.MeshBasicMaterial( { color: 0xffff00 } );
	var torus2 = new THREE.Mesh( geometry, material );
	torus2.rotation.x=29.8;
	torus2.position.y=-7;

	//four lines below create third layer of ufo
	var geometry = new THREE.TorusGeometry( 5, 2, 16, 100 );
	var cylinder = new THREE.Mesh( geometry, material );
	cylinder.position.y=-5;
	cylinder.rotation.x=29.8;

	//five lines below create second top layer
	var geometry = new THREE.CylinderGeometry( 3.9, 3.9, 2, 64 );
	var cylinder2 = new THREE.Mesh( geometry, material );
	cylinder2.position.y=-3;
	cylinder2.rotation.x=31;
	cylinder2.position.x=-0.2;

	//creates the ufo ball(indicator)
	var geometry = new THREE.SphereGeometry( 2, 32, 32 );
	var sphere = new THREE.Mesh( geometry, material );
	sphere.position.y=-2;


	//creates our geometry which will contain all our objects from above
	var geom=new THREE.Geometry();


	//every two lines is the main process for merging objects to one massive object
	torus1.updateMatrix();
	geom.merge(torus1.geometry,torus1.matrix);

	torus2.updateMatrix();
	geom.merge(torus2.geometry,torus2.matrix);

	cylinder.updateMatrix();
	geom.merge(cylinder.geometry,cylinder.matrix);

	cylinder2.updateMatrix();
	geom.merge(cylinder2.geometry,cylinder2.matrix);

	sphere.updateMatrix();
	geom.merge(sphere.geometry,sphere.matrix);

	//loading a texture for our ufo
	var load=new THREE.TextureLoader();
	var mat=load.load('textures/ufob.jpg');
	console.log(cubeMat);
	var ufoMat=new THREE.MeshLambertMaterial({map:mat});
	//final ufo
	var ufo=new Physijs.BoxMesh(geom,ufoMat);

	//y position for ufo
	ufo.position.y=12;
	ufo.setLinearVelocity(new THREE.Vector3(0,0,0));
	ufo.setAngularVelocity(new THREE.Vector3(0,0,0));
	//scales ufo uniformly
	ufo.scale.set(2,2,2);
	scene.add(ufo);

	var directionalLight2=new THREE.DirectionalLight(0xffffff,2);
	scene.add(directionalLight2.target);//directionalLight must have a target
	directionalLight2.position.set(0,170,0);
	directionalLight2.target=ufo;//respective target for directionalLight
	scene.add(directionalLight2);

	return ufo;
}

//function to create big Moon,not in scene anymore as theres a model
function bigMoon(){
	var sphere=new THREE.SphereGeometry(50,32,32);
	var loader=new THREE.TextureLoader();
	var mat=loader.load('textures/bigmoon.jpeg');
	var material=new THREE.MeshBasicMaterial({map:mat});
	var mesh=new THREE.Mesh(sphere,material);
	mesh.position.y=190;
	mesh.position.x=250;
	mesh.position.x=450;
	//adds bigMoon to group mentioned above
	group.add(mesh);
	return mesh;
}



//All these variables used in the update function

var ufo;
var score=0;
var firstTime=1;
var clock=new THREE.Clock();
var bigmoon;
var ball;
	function update(){


//allows to add scene once,if we have functions like createUFO, put it in this if statement so it creates the object once and not every time in the animate loop
		if(firstTime){
			createLand();
			ufo=createUFO();
			addRocket();
			boxes();
			addSatellite();
			//adds camera to ufo
			ufo.add(camera);

			bigmoon=bigMoon();
			ball=createBall();
			//this is where we add that group from above
			scene.add(group);
			//sets firstTime variable to 0 so we can only execute this if statement once for the entire game/level
			firstTime=0;
			//event listener for collision with the ufo and planet
			ufo.addEventListener("collision",function(object){
				var value=ufo.scale.x;
				console.log(value)
				if(object.id==ball.id){
					//scale size of ufo by small amount as a large amount will mess up
						ufo.scale.set(value+0.2,value+0.2,value+0.2);
						ufo.__dirtyScale=true;

				}
			});

		}
	//rotate group around scene
	group.rotation.y+=0.01;

	//ill explain this in the meeting , just know this is what creates the map
	graphics.fillStyle="black";
	graphics.fillRect(0,0,900,900);
	var imgData=graphics.getImageData(0,0,900,900);
	var ufoX=parseInt((ufo.position.x+450)/3);
	var ufoZ=parseInt((ufo.position.z+450)/3);
	console.log(imgData.data[0],imgData.data[1],imgData.data[2],imgData.data[3])
	if(ufoX<150){
		ufoX=150-ufoX+150;
	}
	else if(ufoX>150){
		ufoX=150-(ufoX-150);
	}

	var t=parseInt((ufoX*3600+ufoZ*4)-1);
	var u=parseInt((ufoX*3600+ufoZ*4)-3600-1);
	var v=parseInt((ufoX*3600+ufoZ*4)+3600-1);


	var ballX=parseInt((ball.position.x+450)/3);
	var ballZ=parseInt((ball.position.z+450)/3);
	if(ballX<150){
		ballX=150-ballX+150;
	}
	else if(ballX>150){
		ballX=150-(ballX-150);
	}
	var x=parseInt((ballX*3600+ballZ*4)-1);
	var y=parseInt((ballX*3600+ballZ*4)-3600-1);
	var z=parseInt((ballX*3600+ballZ*4)+3600-1);

	imgData.data[t]=255;
	imgData.data[t+1]=255;
	imgData.data[t+2]=0;
	imgData.data[t+3]=255;
	imgData.data[t+4]=255;
	imgData.data[t+5]=255;
	imgData.data[t+6]=0;
	imgData.data[t+7]=255;
	imgData.data[t-4]=255;
	imgData.data[t-3]=255;
	imgData.data[t-2]=0;
	imgData.data[t-1]=255;
	imgData.data[u]=255;
	imgData.data[u+1]=255
	imgData.data[u+2]=0;
	imgData.data[u+3]=255;
	imgData.data[u+4]=255;
	imgData.data[u+5]=255;
	imgData.data[u+6]=0;
	imgData.data[u+7]=255;
	imgData.data[u-4]=255;
	imgData.data[u-3]=255;
	imgData.data[u-2]=0;
	imgData.data[u-1]=255;
	imgData.data[v]=255;
	imgData.data[v+1]=255;
	imgData.data[v+2]=0;
	imgData.data[v+3]=255;
	imgData.data[v+4]=255;
	imgData.data[v+5]=255;
	imgData.data[v+6]=0;
	imgData.data[v+7]=255;
	imgData.data[v-4]=255;
	imgData.data[v-3]=255;
	imgData.data[v-2]=0;
	imgData.data[v-1]=255;


	imgData.data[x]=255;
	imgData.data[x+1]=0;
	imgData.data[x+2]=0;
	imgData.data[x+3]=255;
	imgData.data[x+4]=255;
	imgData.data[x+5]=0;
	imgData.data[x+6]=0;
	imgData.data[x+7]=255;
	imgData.data[x-4]=255;
	imgData.data[x-3]=0;
	imgData.data[x-2]=0;
	imgData.data[x-1]=255;
	imgData.data[y]=255;
	imgData.data[y+1]=0;
	imgData.data[y+2]=0;
	imgData.data[y+3]=255;
	imgData.data[y+4]=255;
	imgData.data[y+5]=0;
	imgData.data[y+6]=0;
	imgData.data[y+7]=255;
	imgData.data[y-4]=255;
	imgData.data[y-3]=0;
	imgData.data[y-2]=0;
	imgData.data[y-1]=255;
	imgData.data[z]=255;
	imgData.data[z+1]=0;
	imgData.data[z+2]=0;
	imgData.data[z+3]=255;
	imgData.data[z+4]=255;
	imgData.data[z+5]=0;
	imgData.data[z+6]=0;
	imgData.data[z+7]=255;
	imgData.data[z-4]=255;
	imgData.data[z-3]=0;
	imgData.data[z-2]=0;
	imgData.data[z-1]=255;

	for(var i=0;i<Enemies.length;i++){
		var enemyX=parseInt((Enemies[i].position.x+450)/3);
		var enemyZ=parseInt((Enemies[i].position.z+450)/3);
		if(enemyX<150){
			enemyX=150-enemyX+150;
		}
		else if(enemyX>150){
			enemyX=150-(enemyX-150);
		}
		var x=parseInt((enemyX*3600+enemyZ*4)-1);
		var y=parseInt((enemyX*3600+enemyZ*4)-3600-1);
		var z=parseInt((enemyX*3600+enemyZ*4)+3600-1);

		imgData.data[x]=255;
		imgData.data[x+1]=0;
		imgData.data[x+2]=255;
		imgData.data[x+3]=255;
		imgData.data[x+4]=255;
		imgData.data[x+5]=0;
		imgData.data[x+6]=255;
		imgData.data[x+7]=255;
		imgData.data[x-4]=255;
		imgData.data[x-3]=0;
		imgData.data[x-2]=255;
		imgData.data[x-1]=255;
		imgData.data[y]=255;
		imgData.data[y+1]=0;
		imgData.data[y+2]=255;
		imgData.data[y+3]=255;
		imgData.data[y+4]=255;
		imgData.data[y+5]=0;
		imgData.data[y+6]=255;
		imgData.data[y+7]=255;
		imgData.data[y-4]=255;
		imgData.data[y-3]=0;
		imgData.data[y-2]=255;
		imgData.data[y-1]=255;
		imgData.data[z]=255;
		imgData.data[z+1]=0;
		imgData.data[z+2]=255;
		imgData.data[z+3]=255;
		imgData.data[z+4]=255;
		imgData.data[z+5]=0;
		imgData.data[z+6]=255;
		imgData.data[z+7]=255;
		imgData.data[z-4]=255;
		imgData.data[z-3]=0;
		imgData.data[z-2]=255;
		imgData.data[z-1]=255;

	}

	graphics.clearRect(0,0,900,900);
	canvas.width=300;
	canvas.height=300;
	graphics.putImageData(imgData,0,0,0,0,900,900);

	//calls the check function
		check();
		//checks if we win
		if(ufo.scale.x>=3.4){
			//just for now , when we have level 3 then we'll call that html file here
			alert("sup");
		}


		//converts time value to string and adds it to document
		timer.innerHTML=clock.getElapsedTime().toString();
		//calls the function that moves the ufo
		moveUFO();
		//calls change camera orientation function
		change_cam_orientation();

		//always needed in physics scene
		scene.simulate();


	}
		//animate function loop
		function animate(){
			update();
			renderer.render(scene,camera);
			requestAnimationFrame(animate);
		}

		//varaibles used below for movement and change of camera view
		var move_left,move_right,move_up,move_down,pause,jump;
		var change_cam_angle;
		var y_axis=new THREE.Vector3(0,1,0);

//function to check is timer is at a specific time and score is above certain score
		function check(){
			//failure of game objective,this is what will happen if we fail
			if(clock.getElapsedTime()>85 && score<7){
				//resets ufo
				ufo.position.x=0;
				ufo.position.y=20;
				ufo.position.z=0;
				ufo.scale.set(2,2,2);
				//sets it's velocities to 0 to prevent weird movement form ufo after collision
				ufo.setLinearVelocity(new THREE.Vector3(0, 0, 0));
				ufo.setAngularVelocity(new THREE.Vector3(0, 0, 0));
				//always must be done when updating a physijs mesh's position,rotation,scale
				ufo.__dirtyPosition=true;
				//sets score to 0
				score=0;
				scoreText.innerHTML=score.toString();
				clock.stop();
				alert("You have failed this planet");
				clock.start();
			}


		}

		//function to change camera view
		function change_cam_orientation(){
			if(change_cam_angle){
				camera.position.x=200;
				camera.position.y=100;
				camera.position.z=200;
				camera.lookAt(scene.position);
			}
			else{
				camera.position.x=-120;
				camera.position.y=50;
				camera.position.z=0;
				camera.rotation.y=-Math.PI/2;
				camera.lookAt(ufo.position);
			}
		}


		//function for moving ufo just use this for movement
		function moveUFO(){

			if(move_left){
			rot=new THREE.Quaternion().setFromAxisAngle(y_axis,Math.PI/120);
			cur=ufo.quaternion;
			cur.multiplyQuaternions(rot,cur);
			ufo.__dirtyRotation=true;
			}
			else if(move_right){
				rot=new THREE.Quaternion().setFromAxisAngle(y_axis,-Math.PI/120);
				cur=ufo.quaternion;
				cur.multiplyQuaternions(rot,cur);
				ufo.__dirtyRotation=true;
			}
			else if(move_up){
				var curr_rotation=new THREE.Matrix4().extractRotation(ufo.matrix);
				//console.log(curr_rotation);
				var force_vector=new THREE.Vector3(40000,0,0).applyMatrix4(curr_rotation);
				//console.log(force_vector);
				ufo.applyCentralImpulse(force_vector);
				ufo.__dirtyPosition=true;
			}
			else if(move_down){
				var curr_rotation=new THREE.Matrix4().extractRotation(ufo.matrix);
				var force_vector=new THREE.Vector3(-40000,0,0).applyMatrix4(curr_rotation);
				ufo.applyCentralImpulse(force_vector);
				ufo.__dirtyPosition=true;
			}
			else if(pause){
				ufo.setLinearVelocity(new THREE.Vector3(0, 0, 0));
				ufo.setAngularVelocity(new THREE.Vector3(0, 0, 0));
			}
			else if(jump){
				ufo.position.y=90;
				ufo.__dirtyPosition=true;
			}
		}
		//if you press left,right,up,down,spaceBar,ESC,Enter , sets respective variable to 1 for the moveUFO function
		document.addEventListener('keydown',function(event){
			var code=event.keyCode;
			//move_left=0;move_right=0;move_up=0;move_down=0;pause=0;
			if(code==37){
				move_left=1;
			}
			if(code==38){
				move_up=1;
			}
			if(code==39){
				move_right=1;
			}
			if(code==40){
				move_down=1;
			}
			if(code==32){
				pause=1;
			}
			if(code==27){
				change_cam_angle=1;
			}
			if(code==13){
				jump=1;
			}
			if(code==16){
				//this is just here as sometimes the scene takes long to load , thank you WiFi , so just press shift to reset clock and score to 0. If you start the game and see the timer is high just press Shift before starting
				clock.start();
				score=0;
				scoreText.innerHTML=score.toString();
			}
		});

		//when you release left,right,up,down,spaceBar,ESC,Enter , sets respective variable to 0 for the moveUFO function
		document.addEventListener('keyup',function(event){
			var code=event.keyCode;
			//move_left=1;move_right=1;move_up=1;move_down=1;pause=0;
			if(code==37){
				move_left=0;
			}
			if(code==38){
				move_up=0;
			}
			if(code==39){
				move_right=0;
			}
			if(code==40){
				move_down=0;
			}
			if(code==32){
				pause=0;
			}
			if(code==27){
				change_cam_angle=0;
			}
			if(code==13){
				jump=0;
			}
		});

		//event listener for when clicking on screen to set ufo back to original position
		document.addEventListener('click',function(event){
			ufo.position.x=0;
			ufo.position.y=20;
			ufo.position.z=0;
			ufo.setLinearVelocity(new THREE.Vector3(0, 0, 0));
			ufo.setAngularVelocity(new THREE.Vector3(0, 0, 0));
			ufo.__dirtyPosition=true;
		});

//HMU if you need explanation about anything here , for extra shit just google and see how to change some code in the above


		</script>
	</body>
</html>
